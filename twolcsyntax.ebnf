@@grammar::TwolCSyntax
@@left_recursion :: False

expr_start = expression $ ;

rul_start = rule $ ;

def_start = define $ ;

define = left:identifier op:'=' ~ right:expression ';' ;

identifier = token:/[a-zA-Z0-1Ø]+/ ;

rule = double_arrow_rule | right_arrow_rule | exclusion_rule | left_arrow_rule ;

double_arrow_rule = left:expression op:'<=>' ~ right:contexts ';' ;

right_arrow_rule = left:expression op:'=>' ~ right:contexts ';' ;

exclusion_rule = left:expression op:'/<=' ~ right:contexts ';' ;

left_arrow_rule = left:expression op:'<=' ~ right:contexts ';' ;

contexts = context_lst | context ;

context_lst = left:context ',' right:contexts ;

context = left:[expression] '_' right:[expression] ;

expression = composition | term ;

composition = left:term '.o.' ~ right:expression ;

term = union | difference | intersection | factor ;

union = left:factor op:'|' ~ right:term ;

difference = left:factor op:'-' ~ right:term ;

intersection = left:factor op:'&' ~ right:term ;

factor = concatenation | unit ;

concatenation = left:unit right:factor ;

unit =
    | Kleene_plus
    | Kleene_star
    | Upper
    | Lower
    | One_but_not
    | atom
    ;

Kleene_plus = expr:atom '+' ;

Kleene_star = expr:atom '*' ;

Upper = expr:atom '.u' ;

Lower = expr:atom '.l' ;

One_but_not = '\\' expr:atom ;

atom
    = '[' @:subexpression ~ ']'
    | '(' @:optexpression ~ ')'
    | symbol_or_pair
    | boundary ;

subexpression = expr:expression ;

optexpression = expr:expression ;

symbol_or_pair = token:/[a-zåäöšžA-ZØ:{}'´`]+/ ;

boundary = '.#.' ;

